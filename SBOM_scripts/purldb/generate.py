# Copyright 2025 meator
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Purldb generator module."""

import urllib.parse

import git.submodule_parsing
import meson.wrap_info
import proj_types

from . import keys


def generate(
    main_project_purl: str,
    main_project_version: str,
    nmeum_project_version: str,
    msys2_project_version: str,
    submodules: git.submodule_parsing.SubmoduleInfo,
    wraps: dict[str, meson.wrap_info.MesonWrapInfo],
    github_runner_name_ver: str,
    action_gh_release_version: str,
) -> keys.PurlDB:
    """Generate the purldb.

    purldb is a mapping between PurlNames (an internal enum whose enum values do not
    have any inherent meaning; its only function is to act as the index in purldb) and
    proj_types.Purl strings.

    Splitting the purl generation process should make the SBOM generation process
    clearer. All purls need to be referenced at least twice (at the time of creating
    the CycloneDX component and at the time of adding it to dependencies). It is
    therefore useful to store it in a single place to make sure that the same purl is
    used everywhere.

    purls which are OS-specific are **not** generated by this function. Only the purls
    shared by all targets/OSes are generated here.
    """
    PurlNames = keys.PurlNames  # noqa: N806

    _pstr = proj_types.Purl

    result = keys.PurlDB(
        {
            PurlNames.android_tools_static: _pstr(
                f"{main_project_purl}@{main_project_version}"
            ),
            PurlNames.nmeum_android_tools: _pstr(
                f"{PurlNames.nmeum_android_tools}@{nmeum_project_version}"
            ),
            PurlNames.msys2_android_tools: _pstr(
                f"{PurlNames.msys2_android_tools}@{msys2_project_version}"
            ),
            PurlNames.action_gh_release: _pstr(
                f"{PurlNames.action_gh_release}@{action_gh_release_version}"
            ),
            PurlNames.github_runner: _pstr(
                f"{PurlNames.github_runner}@{github_runner_name_ver}"
            ),
        }
    )

    info_pairs = [
        (PurlNames.ags_core, submodules.core),
        (PurlNames.ags_extras, submodules.extras),
        (PurlNames.boringssl, submodules.boringssl),
        (PurlNames.ags_mkbootimg, submodules.mkbootimg),
        (PurlNames.ags_avb, submodules.avb),
        (PurlNames.ags_libbase, submodules.libbase),
        (PurlNames.ags_libziparchive, submodules.libziparchive),
        (PurlNames.ags_adb, submodules.adb),
        (PurlNames.ags_logging, submodules.logging),
    ]

    if submodules.libusb is not None:
        info_pairs.append((PurlNames.libusb, submodules.libusb))
    if submodules.selinux is not None:
        info_pairs.append((PurlNames.ags_selinux, submodules.selinux))

    for purl_name, submodule_info in info_pairs:
        result[purl_name] = _pstr(
            f"pkg:generic/{submodule_info.name}@{submodule_info.pinned_hash}?vcs_url="
            + urllib.parse.quote_plus(
                f"git+{submodule_info.url}@{submodule_info.pinned_hash}"
            )
        )

    for wrap_info in wraps.values():
        result[wrap_info.purl] = _pstr(f"{wrap_info.purl}@{wrap_info.wrapdb_version}")

    return result
